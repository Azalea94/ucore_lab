# 操作系统Lab3实验报告

2012011354
计24
杜鹃

## 练习零：填写已有实验
使用diff命令进行merge

## 练习一：给未被映射的地址映射上物理页  
完成do_pgfault（mm/vmm.c） 函数，给未被映射的地址映射上物理页。 设置访问权限的时候需要参考页面所在 VMA 的权限， 同时需要注意映射物理页时需要操作内存控制结构所指定的页表，而不是内核的页表。

### 设计实现过程
调用`get_pte`函数返回对应地址的二级页表项。如果内容都是0说明这个页表项没有被写过，那么利用`pgdir_alloc_page`函数创建一个新的页。如果创建失败，那么跳转到失败标志。
如果内容不是0说明之前写过这个页表项，所以发生page fault说明这个页被换出去了。所以需要从硬盘的交换分区将其换进来，利用page_insert函数结合权限信息将页表插入页表项。
其中要利用swap_init_ok全局变量判断是否可以从硬盘交换。


### 和标准答案的差别
没有输出失败对应的错误信息。

### PDE和PTE中组成部分对ucore实现页替换算法的潜在用处
PDE和PTE的前20位是为了来寻找页表地址的。之后一些标志位如PTE_W（可写位），如PTE_U（用户态位），可以让操作系统判断缺页异常的原因从而做出相应的处理。再有一些位比如PTE_D，可以在选择换出页的时候根据不同的置换算法选择应该换出的页。

### 缺页服务例程在执行过程中出现页访问异常，硬件需要做哪些事情
记录当前一些基础的硬件寄存器的信息，保存现场。如果能做到异常嵌套就嵌套，如果不能就走向崩溃了吧..

## 练习二：实现寻找虚拟地址对应的页表项
完成vmm.c中的do_pgfault函数， 并且在实现FIFO算法的swap_fifo.c中完成map_swappable和swap_out_vistim函数。 通过对swap的测试。 注意： 在LAB2 EXERCISE 2处填写代码。
### 设计实现过程
在`_fifo_map_swappable`函数中，将传入的页（最近访问页）加到双向链表上。在`_fifo_swap_out_victim`函数中，找到最后的一个页，用`list_del`函数将对应的链表项删除，并返回这个页面的地址。

### 和标准答案的差别
换出时获取页的函数不同而已，标准答案为`head->prev`，`list_prev`也可以实现。

### 实现"extended clock页替换算法"
有支持基础，但需要进行简单的扩展，对page中的标志位（flags参数）进行扩展。设置访问位和修改位。替换时依旧用链表进行顺序遍历，通过flags参数判断是否替换.

- 需要被换出的页的特征是什么  
访问并且修改过。
- ucore中如何判断具有这样特征的页  
通过flags中标志位来判断。
- 何时进行换入和换出操作  
发生缺页异常的时候。

## 重要知识点
- 虚拟内存的概念，虚拟地址和物理地址的关系
- 页表映射
- 页访问异常的处理
- FIFO等页替换算法

关系和差异：  

我认为，原理课主要告诉我们做什么、为什么这么做，而实验主要让我们体会怎么做。  
原理主要在于概念的理解、算法的原理、操作系统的处理流程，实验会涉及到知识和算法的实现。具体来讲，实验突出了两点:  
一是数据结构的合理性，比如双向链表、mm_struct,vmm_struct等，这些数据结构的设计关系到整个操作系统的架构层次；  
二是细节的处理和落实。比如这次的实验，要实现页面置换机制，只考虑页替换算法的设计与实现是远远不够的，还需考虑其他的问题：一个虚拟的页如何与硬盘上的扇区建立对应关系，如何分辨缺页的原因等等。

## 未涉及知识点

- 全局页置换算法


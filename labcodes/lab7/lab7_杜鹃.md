# 操作系统Lab7实验报告

2012011354
计24
杜鹃

## 练习零：填写已有实验
使用understand的merge功能进行merge  
需要修改之前lab的地方有： 
trap.c部分需要 加上run_timer_list 函数 


## 练习 1: 理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题（不需要编码）


###请在实验报告中给出内核级信号量的设计描述， 并说其大致执行流流程。
设计：   
ucore中的信号量的实现采用了关中断的方式保证了对共享资源的互斥访问 ， 通过等待队列让无法获得信号量的进程睡眠等待。   
信号量的数据结构为semaphore_t, 包含了用于计数的整数值value， 和一个进程等待队列
wait_queue， 一个等待的进程会挂在此等待队列上。信号量实现最重要的两个操作是P和V，分别对应的函数是down(semaphore_t *sem)和 up(semaphore_t *sem)。这两个函数的实现主要是根据判断value值是否大于0、对等待队列的入队、删除操作 以及 开关中断实现的。  

大致执行流程：  
首先实现初始化了一个互斥信号量mutex， 然后创建了对应5个哲学家行为的5个信号量s[i]， 并创建5个内核线程代表5个哲学家， 每个内核线程完成了基于信号量的哲学家吃饭睡觉思考行为实现。  
在`phi_take_forks_sema`和`phi_put_forks_sema`函数中涉及到对于临界区的处理，所以会对mutex信号量进行down和up操作保证同一时间进入临界区只有一个进程。  
在`phi_test_sema`函数中，此函数试图占用资源（叉子）所以up（s[i)信号操作。而`phi_take_forks_sema`函数中如果没有分到资源则会对s[i]进行down操作。


###请在实验报告中给出给用户态进程/线程提供信号量机制的设计方案， 并比较说明给内核级提供信号量机制的异同。   
内核中可以直接用`local_intr_save`和`local_intr_restore`函数进行开关中断，而用户线程则不可以。所以用户线程需要主要是ucore中的信号量的实现采用了关中断的方式保证了对共享资源的互斥访问 ， 通过等待队列让无法获得信号量的进程睡眠等待。 

## 练习二：完成内核级条件变量和基于内核级条件变量的哲学家就餐问题

### 设计实现过程  
实现代码比较简单，主要是对已有函数的调用。主要包括：  
1. 对状态的改变`state_condvar`，试图占用资源的时候变为HUNGRY，用完资源后改为THINKING状态。
2. 对资源的操作：试图占用资源时，调用`phi_test_condvar`函数占用资源，此函数会根据是否占用资源成功而对其状态进行修改，如果状态位eating，则说明占用资源成功，否则没有成功，则需要加入等待队列该进程为睡眠状态。而放弃资源时，要去看两边的人是否需要资源，调用` phi_test_condvar`函数即可。

### 和标准答案的差别
与答案基本一致

## 重要知识点
底层：单处理机实现资源互斥的方式（ucore是用开关中断，而多处理机不能用这种方式）
ucore中信号量的具体实现  
条件变量实现管程的方式   



##关系和差异：  

原理课主要讲了信号和管程两种对于资源互斥问题的处理方法，主要讲原理层面上资源互斥带来的问题以及如何处理能够保证资源在同一时间只有一个进程占用。而实验则是其具体实现，其中包含了对于信号量的PV操作的实现，还有一些底层实现的机制，比如开关中断等。
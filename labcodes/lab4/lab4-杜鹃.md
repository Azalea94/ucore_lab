# 操作系统Lab4实验报告

2012011354
计24
杜鹃

## 练习零：填写已有实验
使用understand的merge功能进行merge

## 练习一：分配并初始化一个进程控制块  
alloc_proc函数（位于kern/process/proc.c中） 负 责分配并返回一个新的struct proc_struct结构， 用于存储新建立的内核线程
的管理信息。 ucore需要对这个结构进行最基本的初始化， 你需要完成这个初始化过程。

### 设计实现过程
根据代码中的注释理解各自变量的含义，并进行赋值。

### 和标准答案的差别
无。

###请说明proc_struct中 struct context context 和 struct trapframe *tf 成员 变量含义和在本实验中的作用是啥  
答：context:表示进程运行过程中的状态，主要是一些寄存器的值,包括eip;esp;ebx;ecx;edx;esi;edi;ebp;  
  trapframe: 是进程中断的时候保存到内核堆栈里的数据结构，保存了当前被打断时候一些信息，以便于后续能够恢复。进程中trapframe的建立是在kernel_thread函数的开始就完成的。主要是分配空间、以及对该进程函数入口地址、段寄存器和eip等值的设置。


## 练习二：为新创建的内核线程分配资源

### 设计实现过程
在`do_fork`函数中做一下事情：  
调用alloc_proc， 首先获得一块用户信息块。  
为进程分配一个内核栈。  调用setup_kstack 函数；
复制原进程的内存管理信息到新进程 ，调用copy_mm；
复制原进程上下文到新进程，调用copy_thread；
将新进程添加到进程列表  
唤醒新进程  wakeup_proc 函数
返回新进程号  

### 和标准答案的差别
答案里还加入了开关中断的操作。

### 请说明ucore是否做到给每个新fork的线程一个唯一的id  
是。实现方式是通过get_pid()函数给进程分配一个进程号。get_pid的实现是维护一个0-8192大小的链表，last_pid保存的是上一次分配的进程号，get_pid函数是会返回一个比last_pid大且与链表其他进程号不冲突的第一个号，next_save是为了减少检查冲突的时候避免过多的从头循环，如果比8192大就从1开始重新分配。只要进程号没有超过MAX_PID，则是唯一的。

## 练习三 理解 proc_run 函数和它调用的函数如何完成进程切换的

###在本实验的执行过程中， 创建且运行了几个内核线程？  
两个内核线程，一个是idle,是第0号线程；另一个是init,是1号线程。


###语句 local_intr_save( intr_flag) ; . . . . local_intr_restore( intr_flag) ; 在这里有何作用?请说明理由  
local_intr_save( intr_flag)的作用是关闭中断，并且将此操作之前的中断开闭状态保存到flag中；restore函数是将flag的状态赋给中断状态。  
## 重要知识点
- 线程（进程）控制块的含义和作用
- 线程初始化时的资源分配和管理
- 进程状态的改变和进程的调度
- 切换线程时的操作，保存现场等

关系和差异：  

我认为原理课中比较重要的是线程状态的改变以及进程之间的切换。原理课中主要是宏观的告诉我们如何实现切换，应该保存现场和回复现场。而实验中会在实现方法角度更加深入，如建立了重要的数据结构proc_struct,context,trapframe 等，另外实现切换的部分是汇编代码实现的。这有助于对trapframe的作用和线程切换的过程理解更透彻。

